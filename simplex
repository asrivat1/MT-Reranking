#!/usr/bin/env python
import optparse
import sys
import compute_bleu as cb
import random

THRESHOLD = 0.001
optparser = optparse.OptionParser()
optparser.add_option("-k", "--kbest-list", dest="input", default="data/dev+test.100best", help="100-best translation lists")
optparser.add_option("-l", "--lm", dest="lm", default=-1.0, type="float", help="Language model weight")
optparser.add_option("-t", "--tm1", dest="tm1", default=-0.5, type="float", help="Translation model p(e|f) weight")
optparser.add_option("-s", "--tm2", dest="tm2", default=-0.5, type="float", help="Lexical translation model p_lex(f|e) weight")
(opts, _) = optparser.parse_args()
weights = {'p(e)'       : float(opts.lm) ,
           'p(e|f)'     : float(opts.tm1),
           'p_lex(f|e)' : float(opts.tm2)}

def three_random():
    thetas = []
    for i in range(0,3):
        theta = {}
        for key in weights.keys():
            theta[key] = - random.random()
    return thetas

def bleu_score(theta):
  return cb.compute_bleu(t)

def midpoint(theta1, theta2):
    mid = {}
    for key in theta1.keys():
        mid = (theta1[key] + theta2[key]) / 2.0
    return mid

def add(theta1, theta2):
    added = {}
    for key in theta1.keys():
        added = theta1[key] + theta2[key]
    return added

def subtract(theta1, theta2):
    subtracted = {}
    for key in theta1.keys():
        subtracted = theta1[key] - theta2[key]
    return subtracted

def shrink_triangle(thetas):
    # find the midpoint between good and best
    m = midpoint(thetas[1], thetas[0])
    # find the midpoint between worst and best
    s = midpoint(thetas[2], thetas[0])

    return [thetas[0], m, s]

def refine(thetas):
    m = midpoint(thetas[1], thetas[0])
    c1 = add(m, {k: v / 2.0 for k,v in subtract(m, thetas[2])})
    c2 = add(m, {k: v * 1.5 for k,v in subtract(m, thetas[2])})

    c1_err = bleu_score(c1)
    c2_err = bleu_score(c2)
    worst_err = bleu_score(thetas[2])

    if c1_err < worst_err and c1_err < c2_err:
        thetas[2] = c1
        return thetas
    elif c2_err < worst_err and c2_err < c1_err:
        thetas[2] = c2
        return thetas
    else:
        return shrink_triangle(thetas)

def reflect(thetas):
    m = midpoint(thetas[1], thetas[0])
    r = add(m, subtract(m, thetas[2]))
    e = add(m, add(subtract(m, thetas[2]), subtract(m, thetas[2])))

    m_err = bleu_score(m)
    r_err = bleu_score(r)
    e_err = bleu_score(e)
    worst_err = bleu_score(thetas[2])

    if e_err < r_err < worst_err:
        thetas[2] = e
        return thetas
    elif r_err < worst_err:
        thetas[2] = r
        return thetas
    else:
        return refine(thetas)

def three_random():
    thetas = []
    for i in range(0,3):
        theta = {}
        for key in weights.keys():
            theta[key] = - random.random()
    return thetas

def bleu_score(theta):
  return cb.compute_bleu(t)
  
def simplex():
    old_score = 0.0
    thetas = three_random()
    thetas = sorted(thetas,lambda x: bleu_score(x),reverse=True)
    best_score = thetas[0]
    i = 0
    while abs(old_score - best_score) > THRESHOLD:
        i += 1
        print i
        old_score = best_score
        thetas = reflect(thetas)
        thetas = sorted(thetas,lambda x: bleu_score(x),reverse=True)
        best_score = thetas[0]
    return thetas

def main():
    weights = simplex()
    all_hyps = [pair.split(' ||| ') for pair in open(opts.input)]
    num_sents = len(all_hyps) / 100
    for s in xrange(0, num_sents):
      hyps_for_one_sent = all_hyps[s * 100:s * 100 + 100]
      (best_score, best) = (-1e300, '')
      for (num, hyp, feats) in hyps_for_one_sent:
        score = 0.0
        for feat in feats.split(' '):
          (k, v) = feat.split('=')
          score += weights[k] * float(v)
        if score > best_score:
          (best_score, best) = (score, hyp)
      try: 
        sys.stdout.write("%s\n" % best)
      except (Exception):
        sys.exit(1)

if __name__ == "__main__":
    main()
